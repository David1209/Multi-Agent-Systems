; --- Update beliefs ---
to update-beliefs ;- player funct
  let vis-rad view-team1
  let sound-rad sound-team1
  if (team = 2) [
    set vis-rad view-team2
    set sound-rad sound-team2
  ]
  
  let team-loc table:make
  let oppo-loc table:make
  let ball-loc []
  ; hear
  foreach incoming_messages [
    let mess table:get ? "message"
    ifelse (table:get ? "subject" = "ballpos") [
      set ball-loc mess
    ][ ifelse (item 0 table:get ? "from" = team) [
      ifelse ( (table:get ? "subject") = "teampos") [
        if (item 0 mess != who and not table:has-key? team-loc (item 0 mess) ) [
          table:put team-loc (item 0 mess) (item 1 mess)
        ]
      ][ if ( (table:get ? "subject") = "oppopos") [
        if (not table:has-key? oppo-loc (item 0 mess) ) [
          table:put oppo-loc (item 0 mess) (item 1 mess)
        ]
      ]]
    ][
      ifelse ( (table:get ? "subject") = "oppopos") [
        if (item 0 mess != who and not table:has-key? team-loc (item 0 mess) ) [
          table:put team-loc (item 0 mess) (item 1 mess)
        ]
      ][ if ( (table:get ? "subject") = "teampos") [
        if (not table:has-key? oppo-loc (item 0 mess) ) [
          table:put oppo-loc (item 0 mess) (item 1 mess)
        ]
      ]]
    ]]
  ]
  
  
  ; look
  ask players in-radius vis-rad [
    if (self != myself and not (table:has-key? team-loc who or table:has-key? oppo-loc who) ) [
      ifelse ([team] of self = [team] of myself) [
        table:put team-loc who list xcor ycor
      ][
        table:put oppo-loc who list xcor ycor
      ]
    ]
  ]

  ask balls in-radius vis-rad [
    set ball-loc list xcor ycor
  ]
  
  table:put beliefs "ball-loc" ball-loc
  table:put beliefs "team-loc" team-loc
  table:put beliefs "oppo-loc" oppo-loc
  
end

; --- Update desires ---
to update-desires ;- player funct
  ifelse (table:get beliefs "team-has-ball") [
      set desire "score"
  ] [
    set desire "prevent-score"
  ]
end

; --- Update intentions ---
to update-intentions ;- player funct
  let playstyle table:get beliefs "playstyle"
  let has-ball table:get beliefs "has-ball"
  let other-team 1
  if team = 1
  [
    set other-team 2
  ]
  if desire = "score"
  [
    if playstyle = "off"
    [
      ; our team has the ball and we want to attack
      ifelse has-ball
      [
        ; move ball to goal, if we are close try to score
        ifelse near-goal other-team
        [
          set intention "try-score"
        ]
        [
          set intention "move-forward-with-ball"
        ]
      ]
      [
        ifelse near-goal other-team
        [
          set intention "support-score"
        ]
        [
          set intention "move-forward"
        ]
        
      ]
    ]
    if playstyle = "def" 
    [
      ; our team has the ball and we're keeping background
      ifelse has-ball
      [
        set intention "pass-attacker"
      ]
      [
        ifelse on-own-half
        [
          set intention "help-keeper"
        ]
        [
          set intention "to-own-half"
        ]
      ]
    ]
    if playstyle = "keep"
    [
      ; our team has the ball and i should be keeping
      ifelse near-goal team
      [
        set intention "stay-at-own-goal"
      ]
      [
        set intention "move-to-own-goal"
      ]
    ]
  ]
  if desire = "prevent-score"
  [
    if playstyle = "off"
    [
      ; the opponents have the ball and im going to attack
      set intention "attack-ball-owner"
    ]
    if playstyle = "def" 
    [
      ; the opponents have the ball and im going to defend
      set intention "between-ball-and-goal"
    ]
    if playstyle = "keep"
    [
      ; holy fuck there're coming for me
      set intention "between-ball-and-goal-near-goal"
    ]
  ]
end


; --- Execute actions ---
to execute-actions ;- player funct
  tell-beliefs
  if intention = "try-score"
  [
    ; kick ball to goal of other team
  ]
  if intention = "move-forward-with-ball"
  [
    ; move in the direction of the goal of the opponent, with the ball
  ]
  if intention = "support-score"
  [
    ; attacker is near goal of opponent, ready to attack and we have the ball
  ]
  if intention = "move-forward"
  [
    ; head toward the goal of the opponent without ball
  ]
  if intention = "pass-attacker"
  [
    ; pass the ball to a player who can attack
  ]
  if intention = "help-keeper"
  [
    ; we have the ball, but stay back at our own half in case shit hits the fan
  ]
  if intention = "to-own-half"
  [
    ; return towards our own half
  ]
  if intention = "stay-at-own-goal"
  [
    ; exactly what it says and what a keeper should do
  ]
  if intention = "move-to-own-goal"
  [
    ; move towards our own goal
  ]
  if intention = "attack-ball-owner"
  [
    ; move towards the opponent that has the ball, and try to take it away from him
  ]
  if intention = "between ball-and-goal"
  [
    ; position yourself between the ball and the goal
  ]
  if intention = "between-ball-and-goal-near-goal"
  [
    ; position yourself where the keeper should be
  ]
end


; --- Send messages ---
to send-messages ;- player funct
  let private private-team1
  let rad sound-team1
  if (team = 2) [
    set private private-team2
    set rad sound-team2
  ]

  ifelse (private) [
    foreach outgoing_messages [
      ifelse (item 1 table:get ? "to" = "mates") [
        ask players in-radius rad with [team = item 0 table:get ? "to"] [
          set incoming_messages lput ? incoming_messages
        ]
      ] [ 
        ask players in-radius rad with [who = item 1 table:get ? "to"] [
            set incoming_messages lput ? incoming_messages
        ]
      ]
    ]
  ] []
  
  set outgoing_messages []
end

to tell-beliefs
  ; team positions
  foreach table:to-list table:get beliefs "team-loc" [
    let message table:make
    table:put message "from" list team who
    table:put message "to" list team "mates"
    table:put message "subject" "teampos"
    table:put message "message" ?
    set outgoing_messages lput message outgoing_messages
  ]
  ; opponent positions
  foreach table:to-list table:get beliefs "oppo-loc" [
    let message table:make
    table:put message "from" list team who
    table:put message "to" list team "mates"
    table:put message "subject" "oppopos"
    table:put message "message" ?
    set outgoing_messages lput message outgoing_messages
  ]
  ; ball position
    let message table:make
    table:put message "from" list team who
    table:put message "to" list team "mates"
    table:put message "subject" "ballpos"
    table:put message "message" table:get beliefs "ball-loc"
    set outgoing_messages lput message outgoing_messages
  ; own position
    set message table:make
    table:put message "from" list team who
    table:put message "to" list team "mates"
    table:put message "subject" "teampos"
    table:put message "message" list who (list xcor ycor)
    set outgoing_messages lput message outgoing_messages

end

to shout-message [message] ; - player function
  
  let radius sound-team1
  if team = 2 [ set radius sound-team2 ]
  
  ask players in-radius radius 
  [
    ifelse team = [team] of myself
    [
      ; same team
      shout-to-player self message
    ]
    [
      ; other team 
      if ([team] of myself = 1 and not private-team1) or ([team] of myself = 2 and not private-team2)
      [
        shout-to-player self message
      ]
    ]
  ]
end

to shout-own-team [message] ; player function
  let msg table:make
  table:put msg "to" "mates"
  table:put msg "subject" "shout"
  table:put msg "sendteam" team
  table:put msg "message" message
  set outgoing_messages lput msg outgoing_messages
end

to shout-other-team [message] ; player function
  let msg table:make
  table:put msg "to" "opponents"
  table:put msg "subject" "shout"
  ifelse team = 1
  [
    table:put msg "sendteam" 2
  ]
  [
    table:put msg "sendteam" 1
  ]
  table:put msg "message" message
  set outgoing_messages lput msg outgoing_messages
end


to shout-to-player [player message] ;- player function
  let msg table:make
  table:put msg "from" myself
  table:put msg "subject" "shout"
  table:put msg "message" message
  set outgoing_messages lput msg outgoing_messages
  ask player
  [
    set incoming_messages lput msg incoming_messages
  ]
end

