; --- Update beliefs ---
to update-beliefs ;- player funct
  let team-loc []
  let oppo-loc []
  ; hear
  foreach incoming_messages 
  [
    if ( (table:get ? "subject") = "teampos") 
    [
      set team-loc lput team-loc table:get ? "message"
    ]
    if ( (table:get ? "subject") = "oppopos") 
    [
      set team-loc lput team-loc table:get ? "message"
    ]
    
    
    ;if table:get ? "sendteam" = team xor table:get ? "to" = "opponents"
    ;[
      ; process the shout
    ;]
  ]
  
  
  ; look
  ask players in-radius (table:get beliefs "vis-rad") 
  [
    if (self != myself and not (in team-loc list xcor ycor or in oppo-loc list xcor ycor) ) 
    [
      ifelse ([team] of self = [team] of myself) 
      [
        set team-loc lput list xcor ycor team-loc
      ] 
      [
        set team-loc lput list xcor ycor oppo-loc
      ]
    ]
  ]
  table:put beliefs "team-loc" team-loc
  table:put beliefs "oppo-loc" oppo-loc
  
end

; --- Update desires ---
to update-desires ;- player funct
  ifelse (table:get beliefs "team-has-ball") [
      set desire "score"
  ] [
    set desire "prevent-score"
  ]
end

; --- Update intentions ---
to update-intentions ;- player funct

end


; --- Execute actions ---
to execute-actions ;- player funct
  
end


; --- Send messages ---
to send-messages ;- player funct
  set outgoing_messages []
  foreach table:get beliefs "team-loc" [
    let message table:make
    table:put message "to" "mates"
    table:put message "subject" "teampos"
    table:put message "message" ?
    set outgoing_messages lput message outgoing_messages
  ]
  foreach table:get beliefs "oppo-loc" [
    let message table:make
    table:put message "to" "mates"
    table:put message "subject" "oppopos"
    table:put message "message" ?
    set outgoing_messages lput message outgoing_messages
  ]
end

to shout-message [message] ; - player function
  
  let radius sound-team1
  if team = 2 [ set radius sound-team2 ]
  
  ask players in-radius radius 
  [
    ifelse team = [team] of myself
    [
      ; same team
      shout-to-player self message
    ]
    [
      ; other team 
      if ([team] of myself = 1 and not private-team1) or ([team] of myself = 2 and not private-team2)
      [
        shout-to-player self message
      ]
    ]
  ]
end

to shout-own-team [message] ; player function
  let msg table:make
  table:put msg "to" "mates"
  table:put msg "subject" "shout"
  table:put msg "sendteam" team
  table:put msg "message" message
  set outgoing_messages lput msg outgoing_messages
end

to shout-other-team [message] ; player function
  let msg table:make
  table:put msg "to" "opponents"
  table:put msg "subject" "shout"
  ifelse team = 1
  [
    table:put msg "sendteam" 2
  ]
  [
    table:put msg "sendteam" 1
  ]
  table:put msg "message" message
  set outgoing_messages lput msg outgoing_messages
end


to shout-to-player [player message] ;- player function
  let msg table:make
  table:put msg "from" myself
  table:put msg "subject" "shout"
  table:put msg "message" message
  set outgoing_messages lput msg outgoing_messages
  ask player
  [
    set incoming_messages lput msg incoming_messages
  ]
end

